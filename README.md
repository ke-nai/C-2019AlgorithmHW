# 2019 알고리즘 과제

## HW5
[과제 설명](https://github.com/ke-nai/C-2019AlgorithmHW/blob/main/HW5/hw5.pdf)
### 1. 알고리즘
#### 1) 도시의 x, y축 좌표를 배열에 저장한 뒤 정렬.
![image](https://user-images.githubusercontent.com/66747535/100071403-5e6eaa80-2e7e-11eb-8d2c-f8bdf00d8afa.png)
[그림 1]
![image](https://user-images.githubusercontent.com/66747535/100071407-60386e00-2e7e-11eb-90c9-55c67208dc07.png)
[그림 2]

[그림 1]처럼 모두 오름차순으로 하면 비효율적이고

[그림 2]처럼 비어 있는 x축 까지 고려하려면 정렬을 두 번 해야 되므로

x축은 오름차순, y축은 x값이 홀수냐 짝수냐에 따라 오름차순이나 내림차순으로 정렬.

#### 2) 처음에는 모든 도시를 연결한 채로 시작
![image](https://user-images.githubusercontent.com/66747535/100071517-7d6d3c80-2e7e-11eb-8658-38d66e8f71fa.png)
[그림 3]

처음에 정렬된 모든 도시를 선택된 도시 목록에 넣으면서

각 도시에서 다음 도시까지의 거리(파란색), 다다음 도시까지의 거리(주황색)를 계산하고

파란색 거리를 모두 더해 전체 거리를 계산해둔다.

#### 3) 제외했을 때 가장 거리가 많이 줄어드는 도시를 찾는다.
두 번째 선택된 도시부터 시작해서 해당 도시를 제외시켰을 때 거리의 변화를 확인해서

가장 많이 줄어드는 것을 찾는다. (파랑색 둘 – 주황색이 가장 큰 값)

#### 4) 3)번에서 찾은 도시를 제외 시킨다.
![image](https://user-images.githubusercontent.com/66747535/100071674-a7befa00-2e7e-11eb-9d0a-8b88164f1d36.png)
[그림 4]  
 
해당 도시를 선택된 도시 목록에서 제외시킨다. (이때 뒤에 목록을 당겨줌)

전체 거리를 계산 해준다. (제외 전의 전체 거리 – 파랑색 둘 + 주황색)

그리고 업데이트가 필요한 도시(제외된 도시의 직전 2 도시)의 거리 정보를 새로 계산해준다.

#### 5) 전체 거리가 원하는 수치가 될 때까지 3), 4)번을 반복하고 결과를 출력한다.
![Honeycam 2020-11-24 18-03-18](https://user-images.githubusercontent.com/66747535/100072285-65e28380-2e7f-11eb-98e1-4ba10deebb60.gif)
[그림 5]

알고리즘 반복 시 위와 같은 형태로 연결된 도시가 변한다.

### 2. 알고리즘 한계와 의의
#### 1) 한계
- 전부 연결한 상태에서 제외하면서 구하기 때문에 200...1500의 결과 출력 순서가 반대
- 도시 하나를 제외할 때 가장 거리를 아낄 수 있는 방향으로 제외하지만(greedy) 도시 여러 개를 제외했을 때 최적의 경우라고 할 수 없음
#### 2) 의의
- 모든 경우를 다 확인하는 경우의 시간 복잡도 O(2^N)보다 훨씬 낮은 시간 복잡도(N^2)를 가져서 도시의 수가 아주 많아도 비교적 쉽게 답을 구할 수 있다.
- 이전의 답에 이어서 다음 답을 구하기 때문에 구해야 할 최대 연료량의 가지 수가 많아져도 연산 시간이 별로 늘어나지 않는다.
